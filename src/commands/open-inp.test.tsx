import { render, screen, waitFor } from "@testing-library/react";
import { HydraulicModelBuilder } from "src/__helpers__/hydraulic-model-builder";
import {
  Sel,
  SimulationFailure,
  Store,
  dataAtom,
  fileInfoAtom,
  momentLogAtom,
  simulationAtom,
} from "src/state/jotai";
import { MomentLog } from "src/lib/persistence/moment-log";
import userEvent from "@testing-library/user-event";
import { aTestFile } from "src/__helpers__/file";
import { fMoment } from "src/lib/persistence/moment";
import { useOpenInp } from "./open-inp";
import { aFileInfo, setInitialState } from "src/__helpers__/state";
import { CommandContainer } from "./__helpers__/command-container";
import {
  buildFileSystemHandleMock,
  lastSaveCall,
  stubFileOpen,
  stubFileSave,
} from "src/__helpers__/browser-fs-mock";
import { buildInp } from "src/simulation/build-inp";
import { stubFeatureOff, stubFeatureOn } from "src/__helpers__/feature-flags";

const aMoment = (name: string) => {
  return fMoment(name);
};

describe("open inp", () => {
  describe("openInpFromFs", () => {
    beforeEach(() => {
      stubFeatureOff("FLAG_MADE_BY");
    });

    it("initializes state opening an inp from fs", async () => {
      const newHandle = stubFileOpen();
      const inp = minimalInp({ junctionId: "J1" });
      const store = setInitialState({
        hydraulicModel: HydraulicModelBuilder.empty(),
      });
      const file = aTestFile({ filename: "my-network.inp", content: inp });

      renderComponent({ store });

      await triggerOpenFromFs();

      await doFileSelection(file);

      expect(screen.getByText(/loading/i)).toBeInTheDocument();
      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      const { hydraulicModel } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();

      expect(store.get(fileInfoAtom)!.handle).toEqual(newHandle);
    });

    it("registers in state when the inp was generated by the app", async () => {
      stubFeatureOn("FLAG_MADE_BY");
      const newHandle = stubFileOpen();
      const store = setInitialState();

      renderComponent({ store });

      const inp = anInpMadeByTheApp({ junctionId: "J1" });
      const file = aTestFile({ filename: "my-network.inp", content: inp });
      await triggerOpenFromFs();

      await doFileSelection(file);

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      const { hydraulicModel } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();

      expect(store.get(fileInfoAtom)!.handle).toEqual(newHandle);
      expect(store.get(fileInfoAtom)!.isMadeByApp).toEqual(true);
    });

    it("registers in state when the inp was generated by the app", async () => {
      stubFeatureOn("FLAG_MADE_BY");
      stubFileOpen();
      const store = setInitialState();

      renderComponent({ store });

      const inp = minimalInp({ junctionId: "J1" });
      const file = aTestFile({ filename: "my-network.inp", content: inp });
      await triggerOpenFromFs();

      await doFileSelection(file);

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      const { hydraulicModel } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();

      expect(store.get(fileInfoAtom)!.handle).toEqual(undefined);
      expect(store.get(fileInfoAtom)!.isMadeByApp).toEqual(false);
    });

    it("displays error when cannot process", async () => {
      stubFileOpen();
      const store = setInitialState({
        hydraulicModel: HydraulicModelBuilder.empty(),
      });
      const file = aTestFile({ content: "INVALID" });

      renderComponent({ store });

      await triggerOpenFromFs();

      await doFileSelection(file);

      await waitFor(() =>
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
      );

      expect(screen.getByText(/error/i)).toBeInTheDocument();
      await userEvent.click(screen.getByText(/understood/i));

      expect(screen.queryByText(/error/i)).not.toBeInTheDocument();
    });

    it("removes previous state", async () => {
      const newHandle = stubFileOpen();
      const inp = minimalInp({ junctionId: "J1" });
      const previousSimulation: SimulationFailure = {
        status: "failure",
        report: "ERROR",
        modelVersion: "10",
      };
      const previousSelection: Sel = {
        type: "single",
        id: "ANY",
        parts: [],
      };
      const previousMomentLog = new MomentLog();
      const store = setInitialState({
        hydraulicModel: HydraulicModelBuilder.empty(),
        momentLog: previousMomentLog,
        simulation: previousSimulation,
        selection: previousSelection,
        fileInfo: aFileInfo({
          handle: buildFileSystemHandleMock({ fileName: "old.inp" }),
        }),
      });
      const file = aTestFile({ filename: "my-network.inp", content: inp });

      renderComponent({ store });
      await triggerOpenFromFs();

      await waitFor(() =>
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
      );
      await userEvent.click(screen.getByRole("button", { name: /discard/i }));
      await waitFor(() =>
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
      );
      await doFileSelection(file);

      await waitFor(() =>
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument(),
      );

      const { hydraulicModel, selection } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();
      expect(hydraulicModel.assets.get("P1")).toBeFalsy();

      const updatedMomentLog = store.get(momentLogAtom);
      expect(updatedMomentLog.id).not.toEqual(previousMomentLog.id);

      const simulation = store.get(simulationAtom);
      expect(simulation.status).toEqual("idle");

      expect(selection.type).toEqual("none");

      expect(store.get(fileInfoAtom)!.handle).toEqual(newHandle);
    });

    it("can save previous changes before opening", async () => {
      const newHandle = stubFileOpen();
      stubFileSave();
      const inp = minimalInp({ junctionId: "J1" });
      const momentLogWithChanges = new MomentLog();
      momentLogWithChanges.append(aMoment("A"), aMoment("B"));
      const store = setInitialState({
        hydraulicModel: HydraulicModelBuilder.with().aJunction("J1").build(),
        momentLog: momentLogWithChanges,
      });
      const file = aTestFile({ filename: "my-network.inp", content: inp });

      renderComponent({ store });

      await triggerOpenFromFs();

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });
      expect(screen.getByText(/unsaved/i)).toBeInTheDocument();

      await userEvent.click(
        screen.getByRole("button", { name: /save and continue/i }),
      );

      const lastSave = lastSaveCall();

      expect(await lastSave.contentBlob.text()).toContain("J1");

      await waitFor(() =>
        expect(screen.queryByText(/unsaved/i)).not.toBeInTheDocument(),
      );
      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });
      await doFileSelection(file);

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      const { hydraulicModel } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();

      expect(store.get(fileInfoAtom)!.handle).toEqual(newHandle);
    });

    it("can discard changes when opening a new project", async () => {
      const inp = minimalInp({ junctionId: "J1" });
      const momentLogWithChanges = new MomentLog();
      momentLogWithChanges.append(aMoment("A"), aMoment("B"));
      const store = setInitialState({
        hydraulicModel: HydraulicModelBuilder.empty(),
        momentLog: momentLogWithChanges,
      });
      const file = aTestFile({ filename: "my-network.inp", content: inp });

      renderComponent({ store });

      await triggerOpenFromFs();

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });
      expect(screen.getByText(/unsaved/i)).toBeInTheDocument();

      await userEvent.click(screen.getByRole("button", { name: /discard/i }));

      await waitFor(() =>
        expect(screen.queryByText(/unsaved/i)).not.toBeInTheDocument(),
      );
      await doFileSelection(file);

      await waitFor(() => {
        expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
      });

      const { hydraulicModel } = store.get(dataAtom);
      expect(hydraulicModel.assets.get("J1")).toBeTruthy();
    });
  });

  it("doesnt create model when coordinates not supported", async () => {
    const inp = inpWithoutCoordinates();
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.empty(),
    });
    const file = aTestFile({ filename: "my-network.inp", content: inp });

    renderComponent({ store });

    await triggerOpenFromFs();

    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    expect(screen.getByText(/coordinates missing/i)).toBeInTheDocument();

    await userEvent.click(screen.getByRole("button", { name: /understood/i }));

    expect(screen.queryByText(/coordinates missing/i)).not.toBeInTheDocument();
    const { hydraulicModel } = store.get(dataAtom);
    expect(hydraulicModel.assets.size).toEqual(0);
  });

  it("shows warning when using unsupported features", async () => {
    const inp = inpWithUnsupportedFeatures({ junctionId: "J1" });
    const store = setInitialState({
      hydraulicModel: HydraulicModelBuilder.empty(),
    });
    const file = aTestFile({ filename: "my-network.inp", content: inp });

    renderComponent({ store });

    await triggerOpenFromFs();

    await doFileSelection(file);

    await waitFor(() => {
      expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
    });

    expect(screen.getByText(/not fully supported yet/i)).toBeInTheDocument();

    await userEvent.click(screen.getByRole("button", { name: /understood/i }));

    expect(screen.queryByText(/coordinates missing/i)).not.toBeInTheDocument();
    const { hydraulicModel } = store.get(dataAtom);
    expect(hydraulicModel.assets.get("J1")).toBeTruthy();
  });

  const triggerOpenFromFs = async () => {
    await userEvent.click(
      screen.getByRole("button", { name: "openInpFromFs" }),
    );
  };

  const doFileSelection = async (file: File) => {
    await userEvent.upload(screen.getByTestId("file-upload"), file);
  };

  const TestableComponent = () => {
    const { openInpFromFs } = useOpenInp();

    return (
      <button aria-label="openInpFromFs" onClick={openInpFromFs}>
        Open from fs
      </button>
    );
  };
  const minimalInp = ({
    junctionId = "J1",
  }: {
    junctionId?: string;
  }): string => {
    return `
    [JUNCTIONS]
    ${junctionId}\t10
    [COORDINATES]
    ${junctionId}\t1\t2
    `;
  };
  const inpWithUnsupportedFeatures = ({
    junctionId = "J1",
  }: {
    junctionId?: string;
  }): string => {
    return `
    [JUNCTIONS]
    ${junctionId}\t10
    [VALVES]
    ANY
    [COORDINATES]
    ${junctionId}\t1\t2
    `;
  };

  const inpWithoutCoordinates = ({
    junctionId = "J1",
  }: {
    junctionId?: string;
  } = {}): string => {
    return `
    [JUNCTIONS]
    ${junctionId}\t10
    `;
  };

  const anInpMadeByTheApp = ({ junctionId = "J1" }: { junctionId: string }) => {
    const hydraulicModel = HydraulicModelBuilder.with()
      .aJunction(junctionId, { coordinates: [10, 10] })
      .build();
    const inp = buildInp(hydraulicModel, { madeBy: true, geolocation: true });
    return inp;
  };

  const renderComponent = ({ store }: { store: Store }) => {
    render(
      <CommandContainer store={store}>
        <TestableComponent />
      </CommandContainer>,
    );
  };
});
